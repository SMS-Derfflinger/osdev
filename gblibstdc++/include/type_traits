#ifndef __GBLIBCPP_TYPE_TRAITS__
#define __GBLIBCPP_TYPE_TRAITS__

#include <bits/fwd_functional>
#include <utility>

namespace std {

template <typename... Ts>
using void_t = void;

template <typename T>
struct remove_reference { using type = T; };
template <typename T>
struct remove_reference<T&> { using type = T; };
template <typename T>
struct remove_reference<T&&> { using type = T; };

template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

namespace __helpers {

template <typename T, typename = void> // for cv-void
struct add_rvalue_reference { using type = T; };
template <typename T> // cv-void will fail in substitution
struct add_rvalue_reference<T, void_t<T&&> > { using type = T&&; };

template <typename T, typename = void> // for cv-void
struct add_lvalue_reference { using type = T; };
template <typename T> // cv-void will fail in substitution
struct add_lvalue_reference<T, void_t<T&> > { using type = T&; };

} // namespace __helpers

template <typename T>
struct add_rvalue_reference {
    using type = typename __helpers::add_rvalue_reference<T>::type;
};
template <typename T>
struct add_lvalue_reference {
    using type = typename __helpers::add_lvalue_reference<T>::type;
};

template <typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
template <typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template <typename T>
struct remove_pointer { using type = T; };
template <typename T>
struct remove_pointer<T*> { using type = T; };
template <typename T>
struct remove_pointer<T* const> { using type = T; };
template <typename T>
struct remove_pointer<T* volatile> { using type = T; };
template <typename T>
struct remove_pointer<T* const volatile> { using type = T; };

template <typename T>
using remove_pointer_t = typename remove_pointer<T>::type;

template <typename T>
struct add_pointer { using type = remove_reference_t<T>*; };

template <typename T>
using add_pointer_t = typename add_pointer<T>::type;

template <typename T>
struct remove_cv { using type = T; };
template <typename T>
struct remove_cv<T const> { using type = T; };
template <typename T>
struct remove_cv<T volatile> { using type = T; };
template <typename T>
struct remove_cv<T const volatile> { using type = T; };

template <typename T>
using remove_cv_t = typename remove_cv<T>::type;

template <typename T>
struct add_const { using type = T const; };
template <typename T>
struct add_volatile { using type = T volatile; };
template <typename T>
struct add_cv { using type = T const volatile; };

template <typename T>
using add_const_t = typename add_const<T>::type;
template <typename T>
using add_volatile_t = typename add_volatile<T>::type;
template <typename T>
using add_cv_t = typename add_cv<T>::type;

template <typename T>
struct decay {
private:
    using U = remove_reference_t<T>;
public:
    using type = remove_cv_t<U>;
};

template <typename T>
using decay_t = typename decay<T>::type;

template <typename T, T _value>
struct integral_constant {
    using value_type = T;
    using type = integral_constant;

    static constexpr value_type value = _value;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

template <bool _value>
using bool_constant = integral_constant<bool, _value>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

namespace __helpers {

template <typename>
struct template_true_type : public true_type {};
template <typename>
struct template_false_type : public false_type {};

} // namespace __helpers

template <bool condition, typename T, typename F>
struct conditional { using type = F; };
template <typename T, typename F>
struct conditional<true, T, F> { using type = T; };

template <bool condition, typename T, typename F>
using conditional_t = typename conditional<condition, T, F>::type;

template <typename T, typename U>
struct is_same : public false_type {};
template <typename T>
struct is_same<T, T> : public true_type {};

template <typename T, typename U>
inline constexpr bool is_same_v = is_same<T, U>::value;

template <typename T>
struct is_void : public is_same<remove_cv_t<T>, void> {};

template <typename T>
inline constexpr bool is_void_v = is_void<T>::value;

template <typename T>
struct is_pointer : public false_type {};
template <typename T>
struct is_pointer<T*> : public true_type {};
template <typename T>
struct is_pointer<T* const> : public true_type {};
template <typename T>
struct is_pointer<T* volatile> : public true_type {};
template <typename T>
struct is_pointer<T* const volatile> : public true_type {};

template <typename T>
inline constexpr bool is_pointer_v = is_pointer<T>::value;

template <typename T>
struct is_const : public false_type {};
template <typename T>
struct is_const<T const> : public true_type {};

template <typename T>
inline constexpr bool is_const_v = is_const<T>::value;

template <typename T>
struct is_function : public bool_constant<!is_const_v<const T>> {};
template <typename T>
struct is_function<T&> : public false_type {};
template <typename T>
struct is_function<T&&> : public false_type {};

template <typename T>
inline constexpr bool is_function_v = is_function<T>::value;

template <bool B, typename T = void>
struct enable_if {};
template <typename T>
struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;

template <typename T>
add_rvalue_reference_t<T> declval(void) noexcept
{
    static_assert(__helpers::template_false_type<T>::value, "declval cannot be evaluated.");
}

namespace __helpers {

template <typename From, typename To, typename = void>
struct is_convertible : public false_type {};
template <typename From, typename To>
struct is_convertible<From, To,
    decltype(declval<void(*)(To)>()(declval<From>()))
> : public true_type {};
template <typename Void1, typename Void2>
struct is_convertible<Void1, Void2,
    enable_if_t<is_void_v<Void1> && is_void_v<Void2> >
> : public true_type {};

// TODO: check T is union
template <typename T>
true_type __test_is_class(int T::*);
template <typename T>
false_type __test_is_class(...);

template <typename Base, typename Derived>
auto _try_is_base_of(...) -> true_type;

template <typename Base, typename Derived>
auto _try_is_base_of() ->
    decltype(void());

template <typename Base>
true_type __conv_base_pointer(const volatile Base*);
template <typename>
false_type __conv_base_pointer(const volatile void*);

template <typename Base, typename Derived>
decltype(__conv_base_pointer<Base>(declval<Derived*>()))
try_is_base_of(int);

template <typename, typename>
true_type try_is_base_of(...);

} // namespace __helpers

template <typename From, typename To>
struct is_convertible : public __helpers::is_convertible<From, To> {};

template <typename From, typename To>
inline constexpr bool is_convertible_v = is_convertible<From, To>::value;

template <typename T>
struct is_class : public decltype(__helpers::__test_is_class<T>(nullptr)) {};

template <typename T>
inline constexpr bool is_class_v = is_class<T>::value;

template <typename Base, typename Derived>
struct is_base_of : public bool_constant<
    is_class_v<Base> && is_class_v<Derived>
    && decltype(__helpers::try_is_base_of<Base, Derived>(0))::value
> {};

template <typename Base, typename Derived>
inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;

namespace __helpers {

template <typename>
struct is_reference_wrapper : public false_type {};
template <typename T>
struct is_reference_wrapper<reference_wrapper<T>> : public true_type {};

template <typename FuncType>
struct __invoke_impl {
    template <typename Func, typename... Args>
    static auto __invoke(Func&& func, Args&&... args)
        noexcept(noexcept(forward<Func>(func)(forward<Args>(args)...)))
        -> decltype(forward<Func>(func)(forward<Args>(args)...)) {
        return forward<Func>(func)(forward<Args>(args)...);
    }
};

template <typename T, typename Ret>
struct __invoke_impl<Ret T::*> {
    template <typename _T1, typename T1 = decay_t<_T1>, typename = enable_if_t<
        is_same_v<T, T1> || is_base_of_v<T, T1>
        >>
    static auto get(_T1&& val) -> _T1&& {
        return forward<_T1>(val);
    }

    template <typename _T1, typename T1 = decay_t<_T1>, typename = enable_if_t<
        is_reference_wrapper<T1>::value
        >>
    static auto get(_T1&& val) -> decltype(val.get()) {
        return val.get();
    }

    template <typename _T1, typename T1 = decay_t<_T1>, typename = enable_if_t<
        !is_same_v<T, T1> && !is_base_of_v<T, T1>
        && !is_reference_wrapper<T1>::value
        >>
    static auto get(_T1&& val) -> decltype(*forward<_T1>(val)) {
        return *forward<_T1>(val);
    }

    template <typename T1, typename... Args>
    static auto __invoke(Ret T::*pmf, T1&& t1, Args&&... args)
        noexcept(noexcept((forward<T1>(t1).*pmf)(forward<Args>(args)...)))
        -> decltype((get(forward<T1>(t1)).*pmf)(forward<Args>(args)...)) {
        return (get(forward<T1>(t1)).*pmf)(forward<Args>(args)...);
    }

    template <typename T1>
    static auto __invoke(Ret T::*pdm, T1&& t1) noexcept
        -> decltype(get(forward<T1>(t1)).*pdm) {
        return get(forward<T1>(t1)).*pdm;
    }
};

template <typename Func, typename... Args, typename FuncBase = decay_t<Func>>
auto INVOKE(Func&& func, Args&&... args)
    noexcept(noexcept(__invoke_impl<FuncBase>::__invoke(
        forward<Func>(func), forward<Args>(args)...)))
    -> decltype(__invoke_impl<FuncBase>::__invoke(
        forward<Func>(func), forward<Args>(args)...))
{
    return __invoke_impl<FuncBase>::__invoke(
    forward<Func>(func), forward<Args>(args)...);
}

template <typename Func, typename = void, typename... Args>
struct __is_invocable : public false_type {};

template <typename Func, typename... Args>
struct __is_invocable<Func, void_t<
    decltype(INVOKE(declval<Func>(), declval<Args>()...))>,
    Args...> : public true_type {};

template <typename Func, typename = void, typename... Args>
struct __invoke_result {};

template <typename Func, typename... Args>
struct __invoke_result<Func, enable_if_t<
    __is_invocable<Func, void, Args...>::value
>, Args...> {
    using type = decltype(INVOKE(declval<Func>(), declval<Args>()...));
};

} // namespace __helpers

template <typename Func, typename... Args>
struct is_invocable : __helpers::__is_invocable<Func, void, Args...> {};

template <typename Func, typename... Args>
struct is_nothrow_invocable : bool_constant<
    is_invocable<Func, Args...>::value
    && noexcept(__helpers::INVOKE(declval<Func>(), declval<Args>()...))
> {};

template <typename Func, typename... Args>
inline constexpr bool is_invocable_v = is_invocable<Func, Args...>::value;
template <typename Func, typename... Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<Func, Args...>::value;

template <typename Func, typename... Args>
struct invoke_result : __helpers::__invoke_result<Func, void, Args...> {};

template <class Func, class... Args>
using invoke_result_t = typename invoke_result<Func, Args...>::type;

#define __CPP_GREATBRIDF
#ifdef __CPP_GREATBRIDF

template <typename U, template <typename...> class T, typename...>
struct is_template_instance : public false_type {
};
template <template <typename...> class T, typename... Ts>
struct is_template_instance<T<Ts...>, T, Ts...> : public true_type {
};

template <typename U, template <typename...> class T, typename... Ts>
inline constexpr bool is_template_instance_v = is_template_instance<U, T, Ts...>::value;

template <typename T>
using template_false_type = __helpers::template_false_type<T>;
template <typename T>
using template_true_type = __helpers::template_true_type<T>;

#endif

} // namespace std

#endif
